// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/espitman/jbm-hr-backend/ent/album"
	"github.com/espitman/jbm-hr-backend/ent/department"
	"github.com/espitman/jbm-hr-backend/ent/digikalacode"
	"github.com/espitman/jbm-hr-backend/ent/hrteam"
	"github.com/espitman/jbm-hr-backend/ent/otp"
	"github.com/espitman/jbm-hr-backend/ent/predicate"
	"github.com/espitman/jbm-hr-backend/ent/request"
	"github.com/espitman/jbm-hr-backend/ent/requestmeta"
	"github.com/espitman/jbm-hr-backend/ent/resume"
	"github.com/espitman/jbm-hr-backend/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum        = "Album"
	TypeDepartment   = "Department"
	TypeDigikalaCode = "DigikalaCode"
	TypeHRTeam       = "HRTeam"
	TypeOTP          = "OTP"
	TypeRequest      = "Request"
	TypeRequestMeta  = "RequestMeta"
	TypeResume       = "Resume"
	TypeUser         = "User"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op               Op
	typ              string
	id               *int
	url              *string
	caption          *string
	display_order    *int
	adddisplay_order *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Album, error)
	predicates       []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id int) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *AlbumMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AlbumMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AlbumMutation) ResetURL() {
	m.url = nil
}

// SetCaption sets the "caption" field.
func (m *AlbumMutation) SetCaption(s string) {
	m.caption = &s
}

// Caption returns the value of the "caption" field in the mutation.
func (m *AlbumMutation) Caption() (r string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCaption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ClearCaption clears the value of the "caption" field.
func (m *AlbumMutation) ClearCaption() {
	m.caption = nil
	m.clearedFields[album.FieldCaption] = struct{}{}
}

// CaptionCleared returns if the "caption" field was cleared in this mutation.
func (m *AlbumMutation) CaptionCleared() bool {
	_, ok := m.clearedFields[album.FieldCaption]
	return ok
}

// ResetCaption resets all changes to the "caption" field.
func (m *AlbumMutation) ResetCaption() {
	m.caption = nil
	delete(m.clearedFields, album.FieldCaption)
}

// SetDisplayOrder sets the "display_order" field.
func (m *AlbumMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *AlbumMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *AlbumMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *AlbumMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *AlbumMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Album, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.url != nil {
		fields = append(fields, album.FieldURL)
	}
	if m.caption != nil {
		fields = append(fields, album.FieldCaption)
	}
	if m.display_order != nil {
		fields = append(fields, album.FieldDisplayOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldURL:
		return m.URL()
	case album.FieldCaption:
		return m.Caption()
	case album.FieldDisplayOrder:
		return m.DisplayOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldURL:
		return m.OldURL(ctx)
	case album.FieldCaption:
		return m.OldCaption(ctx)
	case album.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case album.FieldCaption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	case album.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, album.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case album.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case album.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(album.FieldCaption) {
		fields = append(fields, album.FieldCaption)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	switch name {
	case album.FieldCaption:
		m.ClearCaption()
		return nil
	}
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldURL:
		m.ResetURL()
		return nil
	case album.FieldCaption:
		m.ResetCaption()
		return nil
	case album.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Album edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	title            *string
	description      *string
	image            *string
	icon             *string
	color            *string
	shortName        *string
	display_order    *int
	adddisplay_order *int
	clearedFields    map[string]struct{}
	users            map[int]struct{}
	removedusers     map[int]struct{}
	clearedusers     bool
	done             bool
	oldValue         func(context.Context) (*Department, error)
	predicates       []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *DepartmentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DepartmentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DepartmentMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
}

// SetImage sets the "image" field.
func (m *DepartmentMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *DepartmentMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *DepartmentMutation) ResetImage() {
	m.image = nil
}

// SetIcon sets the "icon" field.
func (m *DepartmentMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *DepartmentMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *DepartmentMutation) ResetIcon() {
	m.icon = nil
}

// SetColor sets the "color" field.
func (m *DepartmentMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *DepartmentMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *DepartmentMutation) ResetColor() {
	m.color = nil
}

// SetShortName sets the "shortName" field.
func (m *DepartmentMutation) SetShortName(s string) {
	m.shortName = &s
}

// ShortName returns the value of the "shortName" field in the mutation.
func (m *DepartmentMutation) ShortName() (r string, exists bool) {
	v := m.shortName
	if v == nil {
		return
	}
	return *v, true
}

// OldShortName returns the old "shortName" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldShortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortName: %w", err)
	}
	return oldValue.ShortName, nil
}

// ResetShortName resets all changes to the "shortName" field.
func (m *DepartmentMutation) ResetShortName() {
	m.shortName = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *DepartmentMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *DepartmentMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *DepartmentMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *DepartmentMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *DepartmentMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DepartmentMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DepartmentMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DepartmentMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DepartmentMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DepartmentMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DepartmentMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DepartmentMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.title != nil {
		fields = append(fields, department.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, department.FieldImage)
	}
	if m.icon != nil {
		fields = append(fields, department.FieldIcon)
	}
	if m.color != nil {
		fields = append(fields, department.FieldColor)
	}
	if m.shortName != nil {
		fields = append(fields, department.FieldShortName)
	}
	if m.display_order != nil {
		fields = append(fields, department.FieldDisplayOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldTitle:
		return m.Title()
	case department.FieldDescription:
		return m.Description()
	case department.FieldImage:
		return m.Image()
	case department.FieldIcon:
		return m.Icon()
	case department.FieldColor:
		return m.Color()
	case department.FieldShortName:
		return m.ShortName()
	case department.FieldDisplayOrder:
		return m.DisplayOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldTitle:
		return m.OldTitle(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	case department.FieldImage:
		return m.OldImage(ctx)
	case department.FieldIcon:
		return m.OldIcon(ctx)
	case department.FieldColor:
		return m.OldColor(ctx)
	case department.FieldShortName:
		return m.OldShortName(ctx)
	case department.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case department.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case department.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case department.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case department.FieldShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortName(v)
		return nil
	case department.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, department.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case department.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldTitle:
		m.ResetTitle()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	case department.FieldImage:
		m.ResetImage()
		return nil
	case department.FieldIcon:
		m.ResetIcon()
		return nil
	case department.FieldColor:
		m.ResetColor()
		return nil
	case department.FieldShortName:
		m.ResetShortName()
		return nil
	case department.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, department.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, department.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, department.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DigikalaCodeMutation represents an operation that mutates the DigikalaCode nodes in the graph.
type DigikalaCodeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	code               *string
	used               *bool
	created_at         *time.Time
	assign_at          *time.Time
	clearedFields      map[string]struct{}
	assigned_to        *int
	clearedassigned_to bool
	done               bool
	oldValue           func(context.Context) (*DigikalaCode, error)
	predicates         []predicate.DigikalaCode
}

var _ ent.Mutation = (*DigikalaCodeMutation)(nil)

// digikalacodeOption allows management of the mutation configuration using functional options.
type digikalacodeOption func(*DigikalaCodeMutation)

// newDigikalaCodeMutation creates new mutation for the DigikalaCode entity.
func newDigikalaCodeMutation(c config, op Op, opts ...digikalacodeOption) *DigikalaCodeMutation {
	m := &DigikalaCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeDigikalaCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDigikalaCodeID sets the ID field of the mutation.
func withDigikalaCodeID(id int) digikalacodeOption {
	return func(m *DigikalaCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *DigikalaCode
		)
		m.oldValue = func(ctx context.Context) (*DigikalaCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DigikalaCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDigikalaCode sets the old DigikalaCode of the mutation.
func withDigikalaCode(node *DigikalaCode) digikalacodeOption {
	return func(m *DigikalaCodeMutation) {
		m.oldValue = func(context.Context) (*DigikalaCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DigikalaCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DigikalaCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DigikalaCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DigikalaCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DigikalaCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *DigikalaCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DigikalaCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the DigikalaCode entity.
// If the DigikalaCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DigikalaCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DigikalaCodeMutation) ResetCode() {
	m.code = nil
}

// SetUsed sets the "used" field.
func (m *DigikalaCodeMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *DigikalaCodeMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the DigikalaCode entity.
// If the DigikalaCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DigikalaCodeMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *DigikalaCodeMutation) ResetUsed() {
	m.used = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DigikalaCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DigikalaCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DigikalaCode entity.
// If the DigikalaCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DigikalaCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DigikalaCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAssignToUserID sets the "assign_to_user_id" field.
func (m *DigikalaCodeMutation) SetAssignToUserID(i int) {
	m.assigned_to = &i
}

// AssignToUserID returns the value of the "assign_to_user_id" field in the mutation.
func (m *DigikalaCodeMutation) AssignToUserID() (r int, exists bool) {
	v := m.assigned_to
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignToUserID returns the old "assign_to_user_id" field's value of the DigikalaCode entity.
// If the DigikalaCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DigikalaCodeMutation) OldAssignToUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignToUserID: %w", err)
	}
	return oldValue.AssignToUserID, nil
}

// ClearAssignToUserID clears the value of the "assign_to_user_id" field.
func (m *DigikalaCodeMutation) ClearAssignToUserID() {
	m.assigned_to = nil
	m.clearedFields[digikalacode.FieldAssignToUserID] = struct{}{}
}

// AssignToUserIDCleared returns if the "assign_to_user_id" field was cleared in this mutation.
func (m *DigikalaCodeMutation) AssignToUserIDCleared() bool {
	_, ok := m.clearedFields[digikalacode.FieldAssignToUserID]
	return ok
}

// ResetAssignToUserID resets all changes to the "assign_to_user_id" field.
func (m *DigikalaCodeMutation) ResetAssignToUserID() {
	m.assigned_to = nil
	delete(m.clearedFields, digikalacode.FieldAssignToUserID)
}

// SetAssignAt sets the "assign_at" field.
func (m *DigikalaCodeMutation) SetAssignAt(t time.Time) {
	m.assign_at = &t
}

// AssignAt returns the value of the "assign_at" field in the mutation.
func (m *DigikalaCodeMutation) AssignAt() (r time.Time, exists bool) {
	v := m.assign_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignAt returns the old "assign_at" field's value of the DigikalaCode entity.
// If the DigikalaCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DigikalaCodeMutation) OldAssignAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignAt: %w", err)
	}
	return oldValue.AssignAt, nil
}

// ClearAssignAt clears the value of the "assign_at" field.
func (m *DigikalaCodeMutation) ClearAssignAt() {
	m.assign_at = nil
	m.clearedFields[digikalacode.FieldAssignAt] = struct{}{}
}

// AssignAtCleared returns if the "assign_at" field was cleared in this mutation.
func (m *DigikalaCodeMutation) AssignAtCleared() bool {
	_, ok := m.clearedFields[digikalacode.FieldAssignAt]
	return ok
}

// ResetAssignAt resets all changes to the "assign_at" field.
func (m *DigikalaCodeMutation) ResetAssignAt() {
	m.assign_at = nil
	delete(m.clearedFields, digikalacode.FieldAssignAt)
}

// SetAssignedToID sets the "assigned_to" edge to the User entity by id.
func (m *DigikalaCodeMutation) SetAssignedToID(id int) {
	m.assigned_to = &id
}

// ClearAssignedTo clears the "assigned_to" edge to the User entity.
func (m *DigikalaCodeMutation) ClearAssignedTo() {
	m.clearedassigned_to = true
	m.clearedFields[digikalacode.FieldAssignToUserID] = struct{}{}
}

// AssignedToCleared reports if the "assigned_to" edge to the User entity was cleared.
func (m *DigikalaCodeMutation) AssignedToCleared() bool {
	return m.AssignToUserIDCleared() || m.clearedassigned_to
}

// AssignedToID returns the "assigned_to" edge ID in the mutation.
func (m *DigikalaCodeMutation) AssignedToID() (id int, exists bool) {
	if m.assigned_to != nil {
		return *m.assigned_to, true
	}
	return
}

// AssignedToIDs returns the "assigned_to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedToID instead. It exists only for internal usage by the builders.
func (m *DigikalaCodeMutation) AssignedToIDs() (ids []int) {
	if id := m.assigned_to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedTo resets all changes to the "assigned_to" edge.
func (m *DigikalaCodeMutation) ResetAssignedTo() {
	m.assigned_to = nil
	m.clearedassigned_to = false
}

// Where appends a list predicates to the DigikalaCodeMutation builder.
func (m *DigikalaCodeMutation) Where(ps ...predicate.DigikalaCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DigikalaCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DigikalaCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DigikalaCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DigikalaCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DigikalaCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DigikalaCode).
func (m *DigikalaCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DigikalaCodeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, digikalacode.FieldCode)
	}
	if m.used != nil {
		fields = append(fields, digikalacode.FieldUsed)
	}
	if m.created_at != nil {
		fields = append(fields, digikalacode.FieldCreatedAt)
	}
	if m.assigned_to != nil {
		fields = append(fields, digikalacode.FieldAssignToUserID)
	}
	if m.assign_at != nil {
		fields = append(fields, digikalacode.FieldAssignAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DigikalaCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case digikalacode.FieldCode:
		return m.Code()
	case digikalacode.FieldUsed:
		return m.Used()
	case digikalacode.FieldCreatedAt:
		return m.CreatedAt()
	case digikalacode.FieldAssignToUserID:
		return m.AssignToUserID()
	case digikalacode.FieldAssignAt:
		return m.AssignAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DigikalaCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case digikalacode.FieldCode:
		return m.OldCode(ctx)
	case digikalacode.FieldUsed:
		return m.OldUsed(ctx)
	case digikalacode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case digikalacode.FieldAssignToUserID:
		return m.OldAssignToUserID(ctx)
	case digikalacode.FieldAssignAt:
		return m.OldAssignAt(ctx)
	}
	return nil, fmt.Errorf("unknown DigikalaCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DigikalaCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case digikalacode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case digikalacode.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case digikalacode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case digikalacode.FieldAssignToUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignToUserID(v)
		return nil
	case digikalacode.FieldAssignAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignAt(v)
		return nil
	}
	return fmt.Errorf("unknown DigikalaCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DigikalaCodeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DigikalaCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DigikalaCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DigikalaCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DigikalaCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(digikalacode.FieldAssignToUserID) {
		fields = append(fields, digikalacode.FieldAssignToUserID)
	}
	if m.FieldCleared(digikalacode.FieldAssignAt) {
		fields = append(fields, digikalacode.FieldAssignAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DigikalaCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DigikalaCodeMutation) ClearField(name string) error {
	switch name {
	case digikalacode.FieldAssignToUserID:
		m.ClearAssignToUserID()
		return nil
	case digikalacode.FieldAssignAt:
		m.ClearAssignAt()
		return nil
	}
	return fmt.Errorf("unknown DigikalaCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DigikalaCodeMutation) ResetField(name string) error {
	switch name {
	case digikalacode.FieldCode:
		m.ResetCode()
		return nil
	case digikalacode.FieldUsed:
		m.ResetUsed()
		return nil
	case digikalacode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case digikalacode.FieldAssignToUserID:
		m.ResetAssignToUserID()
		return nil
	case digikalacode.FieldAssignAt:
		m.ResetAssignAt()
		return nil
	}
	return fmt.Errorf("unknown DigikalaCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DigikalaCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.assigned_to != nil {
		edges = append(edges, digikalacode.EdgeAssignedTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DigikalaCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case digikalacode.EdgeAssignedTo:
		if id := m.assigned_to; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DigikalaCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DigikalaCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DigikalaCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassigned_to {
		edges = append(edges, digikalacode.EdgeAssignedTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DigikalaCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case digikalacode.EdgeAssignedTo:
		return m.clearedassigned_to
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DigikalaCodeMutation) ClearEdge(name string) error {
	switch name {
	case digikalacode.EdgeAssignedTo:
		m.ClearAssignedTo()
		return nil
	}
	return fmt.Errorf("unknown DigikalaCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DigikalaCodeMutation) ResetEdge(name string) error {
	switch name {
	case digikalacode.EdgeAssignedTo:
		m.ResetAssignedTo()
		return nil
	}
	return fmt.Errorf("unknown DigikalaCode edge %s", name)
}

// HRTeamMutation represents an operation that mutates the HRTeam nodes in the graph.
type HRTeamMutation struct {
	config
	op               Op
	typ              string
	id               *int
	full_name        *string
	role             *string
	email            *string
	phone            *string
	display_order    *int
	adddisplay_order *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*HRTeam, error)
	predicates       []predicate.HRTeam
}

var _ ent.Mutation = (*HRTeamMutation)(nil)

// hrteamOption allows management of the mutation configuration using functional options.
type hrteamOption func(*HRTeamMutation)

// newHRTeamMutation creates new mutation for the HRTeam entity.
func newHRTeamMutation(c config, op Op, opts ...hrteamOption) *HRTeamMutation {
	m := &HRTeamMutation{
		config:        c,
		op:            op,
		typ:           TypeHRTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHRTeamID sets the ID field of the mutation.
func withHRTeamID(id int) hrteamOption {
	return func(m *HRTeamMutation) {
		var (
			err   error
			once  sync.Once
			value *HRTeam
		)
		m.oldValue = func(ctx context.Context) (*HRTeam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HRTeam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHRTeam sets the old HRTeam of the mutation.
func withHRTeam(node *HRTeam) hrteamOption {
	return func(m *HRTeamMutation) {
		m.oldValue = func(context.Context) (*HRTeam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HRTeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HRTeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HRTeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HRTeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HRTeam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFullName sets the "full_name" field.
func (m *HRTeamMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *HRTeamMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the HRTeam entity.
// If the HRTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HRTeamMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *HRTeamMutation) ResetFullName() {
	m.full_name = nil
}

// SetRole sets the "role" field.
func (m *HRTeamMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *HRTeamMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the HRTeam entity.
// If the HRTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HRTeamMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *HRTeamMutation) ResetRole() {
	m.role = nil
}

// SetEmail sets the "email" field.
func (m *HRTeamMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *HRTeamMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the HRTeam entity.
// If the HRTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HRTeamMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *HRTeamMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *HRTeamMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *HRTeamMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the HRTeam entity.
// If the HRTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HRTeamMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *HRTeamMutation) ResetPhone() {
	m.phone = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *HRTeamMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *HRTeamMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the HRTeam entity.
// If the HRTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HRTeamMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *HRTeamMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *HRTeamMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *HRTeamMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// Where appends a list predicates to the HRTeamMutation builder.
func (m *HRTeamMutation) Where(ps ...predicate.HRTeam) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HRTeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HRTeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HRTeam, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HRTeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HRTeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HRTeam).
func (m *HRTeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HRTeamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.full_name != nil {
		fields = append(fields, hrteam.FieldFullName)
	}
	if m.role != nil {
		fields = append(fields, hrteam.FieldRole)
	}
	if m.email != nil {
		fields = append(fields, hrteam.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, hrteam.FieldPhone)
	}
	if m.display_order != nil {
		fields = append(fields, hrteam.FieldDisplayOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HRTeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hrteam.FieldFullName:
		return m.FullName()
	case hrteam.FieldRole:
		return m.Role()
	case hrteam.FieldEmail:
		return m.Email()
	case hrteam.FieldPhone:
		return m.Phone()
	case hrteam.FieldDisplayOrder:
		return m.DisplayOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HRTeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hrteam.FieldFullName:
		return m.OldFullName(ctx)
	case hrteam.FieldRole:
		return m.OldRole(ctx)
	case hrteam.FieldEmail:
		return m.OldEmail(ctx)
	case hrteam.FieldPhone:
		return m.OldPhone(ctx)
	case hrteam.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	}
	return nil, fmt.Errorf("unknown HRTeam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HRTeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hrteam.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case hrteam.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case hrteam.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case hrteam.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case hrteam.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown HRTeam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HRTeamMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, hrteam.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HRTeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hrteam.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HRTeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hrteam.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown HRTeam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HRTeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HRTeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HRTeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HRTeam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HRTeamMutation) ResetField(name string) error {
	switch name {
	case hrteam.FieldFullName:
		m.ResetFullName()
		return nil
	case hrteam.FieldRole:
		m.ResetRole()
		return nil
	case hrteam.FieldEmail:
		m.ResetEmail()
		return nil
	case hrteam.FieldPhone:
		m.ResetPhone()
		return nil
	case hrteam.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	}
	return fmt.Errorf("unknown HRTeam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HRTeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HRTeamMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HRTeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HRTeamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HRTeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HRTeamMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HRTeamMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HRTeam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HRTeamMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HRTeam edge %s", name)
}

// OTPMutation represents an operation that mutates the OTP nodes in the graph.
type OTPMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	expires_at    *time.Time
	used          *bool
	created_at    *time.Time
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*OTP, error)
	predicates    []predicate.OTP
}

var _ ent.Mutation = (*OTPMutation)(nil)

// otpOption allows management of the mutation configuration using functional options.
type otpOption func(*OTPMutation)

// newOTPMutation creates new mutation for the OTP entity.
func newOTPMutation(c config, op Op, opts ...otpOption) *OTPMutation {
	m := &OTPMutation{
		config:        c,
		op:            op,
		typ:           TypeOTP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOTPID sets the ID field of the mutation.
func withOTPID(id int) otpOption {
	return func(m *OTPMutation) {
		var (
			err   error
			once  sync.Once
			value *OTP
		)
		m.oldValue = func(ctx context.Context) (*OTP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OTP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOTP sets the old OTP of the mutation.
func withOTP(node *OTP) otpOption {
	return func(m *OTPMutation) {
		m.oldValue = func(context.Context) (*OTP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OTPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OTPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OTPMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OTPMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OTP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *OTPMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OTPMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *OTPMutation) ResetCode() {
	m.code = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OTPMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OTPMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OTPMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsed sets the "used" field.
func (m *OTPMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *OTPMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *OTPMutation) ResetUsed() {
	m.used = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OTPMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OTPMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OTPMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *OTPMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *OTPMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *OTPMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[otp.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *OTPMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[otp.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *OTPMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, otp.FieldUsedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OTPMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OTPMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OTPMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OTPMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OTPMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OTPMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OTPMutation builder.
func (m *OTPMutation) Where(ps ...predicate.OTP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OTPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OTPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OTP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OTPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OTPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OTP).
func (m *OTPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OTPMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, otp.FieldCode)
	}
	if m.expires_at != nil {
		fields = append(fields, otp.FieldExpiresAt)
	}
	if m.used != nil {
		fields = append(fields, otp.FieldUsed)
	}
	if m.created_at != nil {
		fields = append(fields, otp.FieldCreatedAt)
	}
	if m.used_at != nil {
		fields = append(fields, otp.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OTPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case otp.FieldCode:
		return m.Code()
	case otp.FieldExpiresAt:
		return m.ExpiresAt()
	case otp.FieldUsed:
		return m.Used()
	case otp.FieldCreatedAt:
		return m.CreatedAt()
	case otp.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OTPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case otp.FieldCode:
		return m.OldCode(ctx)
	case otp.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case otp.FieldUsed:
		return m.OldUsed(ctx)
	case otp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case otp.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OTP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OTPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case otp.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case otp.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case otp.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case otp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case otp.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OTP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OTPMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OTPMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OTPMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OTP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OTPMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(otp.FieldUsedAt) {
		fields = append(fields, otp.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OTPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OTPMutation) ClearField(name string) error {
	switch name {
	case otp.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown OTP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OTPMutation) ResetField(name string) error {
	switch name {
	case otp.FieldCode:
		m.ResetCode()
		return nil
	case otp.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case otp.FieldUsed:
		m.ResetUsed()
		return nil
	case otp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case otp.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown OTP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OTPMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, otp.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OTPMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case otp.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OTPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OTPMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OTPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, otp.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OTPMutation) EdgeCleared(name string) bool {
	switch name {
	case otp.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OTPMutation) ClearEdge(name string) error {
	switch name {
	case otp.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OTP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OTPMutation) ResetEdge(name string) error {
	switch name {
	case otp.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OTP edge %s", name)
}

// RequestMutation represents an operation that mutates the Request nodes in the graph.
type RequestMutation struct {
	config
	op            Op
	typ           string
	id            *int
	full_name     *string
	kind          *request.Kind
	description   *string
	status        *request.Status
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	meta          map[int]struct{}
	removedmeta   map[int]struct{}
	clearedmeta   bool
	done          bool
	oldValue      func(context.Context) (*Request, error)
	predicates    []predicate.Request
}

var _ ent.Mutation = (*RequestMutation)(nil)

// requestOption allows management of the mutation configuration using functional options.
type requestOption func(*RequestMutation)

// newRequestMutation creates new mutation for the Request entity.
func newRequestMutation(c config, op Op, opts ...requestOption) *RequestMutation {
	m := &RequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestID sets the ID field of the mutation.
func withRequestID(id int) requestOption {
	return func(m *RequestMutation) {
		var (
			err   error
			once  sync.Once
			value *Request
		)
		m.oldValue = func(ctx context.Context) (*Request, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Request.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequest sets the old Request of the mutation.
func withRequest(node *Request) requestOption {
	return func(m *RequestMutation) {
		m.oldValue = func(context.Context) (*Request, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Request.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *RequestMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RequestMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RequestMutation) ResetUserID() {
	m.user = nil
}

// SetFullName sets the "full_name" field.
func (m *RequestMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *RequestMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *RequestMutation) ResetFullName() {
	m.full_name = nil
}

// SetKind sets the "kind" field.
func (m *RequestMutation) SetKind(r request.Kind) {
	m.kind = &r
}

// Kind returns the value of the "kind" field in the mutation.
func (m *RequestMutation) Kind() (r request.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldKind(ctx context.Context) (v request.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *RequestMutation) ResetKind() {
	m.kind = nil
}

// SetDescription sets the "description" field.
func (m *RequestMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RequestMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RequestMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[request.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RequestMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[request.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RequestMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, request.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *RequestMutation) SetStatus(r request.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestMutation) Status() (r request.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStatus(ctx context.Context) (v request.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RequestMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[request.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RequestMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RequestMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMetumIDs adds the "meta" edge to the RequestMeta entity by ids.
func (m *RequestMutation) AddMetumIDs(ids ...int) {
	if m.meta == nil {
		m.meta = make(map[int]struct{})
	}
	for i := range ids {
		m.meta[ids[i]] = struct{}{}
	}
}

// ClearMeta clears the "meta" edge to the RequestMeta entity.
func (m *RequestMutation) ClearMeta() {
	m.clearedmeta = true
}

// MetaCleared reports if the "meta" edge to the RequestMeta entity was cleared.
func (m *RequestMutation) MetaCleared() bool {
	return m.clearedmeta
}

// RemoveMetumIDs removes the "meta" edge to the RequestMeta entity by IDs.
func (m *RequestMutation) RemoveMetumIDs(ids ...int) {
	if m.removedmeta == nil {
		m.removedmeta = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.meta, ids[i])
		m.removedmeta[ids[i]] = struct{}{}
	}
}

// RemovedMeta returns the removed IDs of the "meta" edge to the RequestMeta entity.
func (m *RequestMutation) RemovedMetaIDs() (ids []int) {
	for id := range m.removedmeta {
		ids = append(ids, id)
	}
	return
}

// MetaIDs returns the "meta" edge IDs in the mutation.
func (m *RequestMutation) MetaIDs() (ids []int) {
	for id := range m.meta {
		ids = append(ids, id)
	}
	return
}

// ResetMeta resets all changes to the "meta" edge.
func (m *RequestMutation) ResetMeta() {
	m.meta = nil
	m.clearedmeta = false
	m.removedmeta = nil
}

// Where appends a list predicates to the RequestMutation builder.
func (m *RequestMutation) Where(ps ...predicate.Request) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Request, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Request).
func (m *RequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, request.FieldUserID)
	}
	if m.full_name != nil {
		fields = append(fields, request.FieldFullName)
	}
	if m.kind != nil {
		fields = append(fields, request.FieldKind)
	}
	if m.description != nil {
		fields = append(fields, request.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, request.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, request.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, request.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case request.FieldUserID:
		return m.UserID()
	case request.FieldFullName:
		return m.FullName()
	case request.FieldKind:
		return m.Kind()
	case request.FieldDescription:
		return m.Description()
	case request.FieldStatus:
		return m.Status()
	case request.FieldCreatedAt:
		return m.CreatedAt()
	case request.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case request.FieldUserID:
		return m.OldUserID(ctx)
	case request.FieldFullName:
		return m.OldFullName(ctx)
	case request.FieldKind:
		return m.OldKind(ctx)
	case request.FieldDescription:
		return m.OldDescription(ctx)
	case request.FieldStatus:
		return m.OldStatus(ctx)
	case request.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case request.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Request field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case request.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case request.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case request.FieldKind:
		v, ok := value.(request.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case request.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case request.FieldStatus:
		v, ok := value.(request.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case request.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case request.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Request numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(request.FieldDescription) {
		fields = append(fields, request.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMutation) ClearField(name string) error {
	switch name {
	case request.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Request nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMutation) ResetField(name string) error {
	switch name {
	case request.FieldUserID:
		m.ResetUserID()
		return nil
	case request.FieldFullName:
		m.ResetFullName()
		return nil
	case request.FieldKind:
		m.ResetKind()
		return nil
	case request.FieldDescription:
		m.ResetDescription()
		return nil
	case request.FieldStatus:
		m.ResetStatus()
		return nil
	case request.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case request.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, request.EdgeUser)
	}
	if m.meta != nil {
		edges = append(edges, request.EdgeMeta)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeMeta:
		ids := make([]ent.Value, 0, len(m.meta))
		for id := range m.meta {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmeta != nil {
		edges = append(edges, request.EdgeMeta)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeMeta:
		ids := make([]ent.Value, 0, len(m.removedmeta))
		for id := range m.removedmeta {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, request.EdgeUser)
	}
	if m.clearedmeta {
		edges = append(edges, request.EdgeMeta)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMutation) EdgeCleared(name string) bool {
	switch name {
	case request.EdgeUser:
		return m.cleareduser
	case request.EdgeMeta:
		return m.clearedmeta
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMutation) ClearEdge(name string) error {
	switch name {
	case request.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Request unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMutation) ResetEdge(name string) error {
	switch name {
	case request.EdgeUser:
		m.ResetUser()
		return nil
	case request.EdgeMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown Request edge %s", name)
}

// RequestMetaMutation represents an operation that mutates the RequestMeta nodes in the graph.
type RequestMetaMutation struct {
	config
	op             Op
	typ            string
	id             *int
	key            *string
	value          *string
	clearedFields  map[string]struct{}
	request        *int
	clearedrequest bool
	done           bool
	oldValue       func(context.Context) (*RequestMeta, error)
	predicates     []predicate.RequestMeta
}

var _ ent.Mutation = (*RequestMetaMutation)(nil)

// requestmetaOption allows management of the mutation configuration using functional options.
type requestmetaOption func(*RequestMetaMutation)

// newRequestMetaMutation creates new mutation for the RequestMeta entity.
func newRequestMetaMutation(c config, op Op, opts ...requestmetaOption) *RequestMetaMutation {
	m := &RequestMetaMutation{
		config:        c,
		op:            op,
		typ:           TypeRequestMeta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestMetaID sets the ID field of the mutation.
func withRequestMetaID(id int) requestmetaOption {
	return func(m *RequestMetaMutation) {
		var (
			err   error
			once  sync.Once
			value *RequestMeta
		)
		m.oldValue = func(ctx context.Context) (*RequestMeta, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequestMeta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequestMeta sets the old RequestMeta of the mutation.
func withRequestMeta(node *RequestMeta) requestmetaOption {
	return func(m *RequestMetaMutation) {
		m.oldValue = func(context.Context) (*RequestMeta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMetaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMetaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMetaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMetaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequestMeta.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestID sets the "request_id" field.
func (m *RequestMetaMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *RequestMetaMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the RequestMeta entity.
// If the RequestMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMetaMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *RequestMetaMutation) ResetRequestID() {
	m.request = nil
}

// SetKey sets the "key" field.
func (m *RequestMetaMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *RequestMetaMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the RequestMeta entity.
// If the RequestMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMetaMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *RequestMetaMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *RequestMetaMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RequestMetaMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the RequestMeta entity.
// If the RequestMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMetaMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RequestMetaMutation) ResetValue() {
	m.value = nil
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *RequestMetaMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[requestmeta.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *RequestMetaMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *RequestMetaMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *RequestMetaMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// Where appends a list predicates to the RequestMetaMutation builder.
func (m *RequestMetaMutation) Where(ps ...predicate.RequestMeta) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMetaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMetaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RequestMeta, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMetaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMetaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RequestMeta).
func (m *RequestMetaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMetaMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.request != nil {
		fields = append(fields, requestmeta.FieldRequestID)
	}
	if m.key != nil {
		fields = append(fields, requestmeta.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, requestmeta.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMetaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requestmeta.FieldRequestID:
		return m.RequestID()
	case requestmeta.FieldKey:
		return m.Key()
	case requestmeta.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMetaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requestmeta.FieldRequestID:
		return m.OldRequestID(ctx)
	case requestmeta.FieldKey:
		return m.OldKey(ctx)
	case requestmeta.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown RequestMeta field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMetaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requestmeta.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case requestmeta.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case requestmeta.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown RequestMeta field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMetaMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMetaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMetaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RequestMeta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMetaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMetaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMetaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RequestMeta nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMetaMutation) ResetField(name string) error {
	switch name {
	case requestmeta.FieldRequestID:
		m.ResetRequestID()
		return nil
	case requestmeta.FieldKey:
		m.ResetKey()
		return nil
	case requestmeta.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown RequestMeta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMetaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.request != nil {
		edges = append(edges, requestmeta.EdgeRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMetaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case requestmeta.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMetaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMetaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMetaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequest {
		edges = append(edges, requestmeta.EdgeRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMetaMutation) EdgeCleared(name string) bool {
	switch name {
	case requestmeta.EdgeRequest:
		return m.clearedrequest
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMetaMutation) ClearEdge(name string) error {
	switch name {
	case requestmeta.EdgeRequest:
		m.ClearRequest()
		return nil
	}
	return fmt.Errorf("unknown RequestMeta unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMetaMutation) ResetEdge(name string) error {
	switch name {
	case requestmeta.EdgeRequest:
		m.ResetRequest()
		return nil
	}
	return fmt.Errorf("unknown RequestMeta edge %s", name)
}

// ResumeMutation represents an operation that mutates the Resume nodes in the graph.
type ResumeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	introduced_name  *string
	introduced_phone *string
	position         *string
	file             *string
	status           *resume.Status
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Resume, error)
	predicates       []predicate.Resume
}

var _ ent.Mutation = (*ResumeMutation)(nil)

// resumeOption allows management of the mutation configuration using functional options.
type resumeOption func(*ResumeMutation)

// newResumeMutation creates new mutation for the Resume entity.
func newResumeMutation(c config, op Op, opts ...resumeOption) *ResumeMutation {
	m := &ResumeMutation{
		config:        c,
		op:            op,
		typ:           TypeResume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeID sets the ID field of the mutation.
func withResumeID(id int) resumeOption {
	return func(m *ResumeMutation) {
		var (
			err   error
			once  sync.Once
			value *Resume
		)
		m.oldValue = func(ctx context.Context) (*Resume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResume sets the old Resume of the mutation.
func withResume(node *Resume) resumeOption {
	return func(m *ResumeMutation) {
		m.oldValue = func(context.Context) (*Resume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIntroducedName sets the "introduced_name" field.
func (m *ResumeMutation) SetIntroducedName(s string) {
	m.introduced_name = &s
}

// IntroducedName returns the value of the "introduced_name" field in the mutation.
func (m *ResumeMutation) IntroducedName() (r string, exists bool) {
	v := m.introduced_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroducedName returns the old "introduced_name" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldIntroducedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroducedName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroducedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroducedName: %w", err)
	}
	return oldValue.IntroducedName, nil
}

// ResetIntroducedName resets all changes to the "introduced_name" field.
func (m *ResumeMutation) ResetIntroducedName() {
	m.introduced_name = nil
}

// SetIntroducedPhone sets the "introduced_phone" field.
func (m *ResumeMutation) SetIntroducedPhone(s string) {
	m.introduced_phone = &s
}

// IntroducedPhone returns the value of the "introduced_phone" field in the mutation.
func (m *ResumeMutation) IntroducedPhone() (r string, exists bool) {
	v := m.introduced_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroducedPhone returns the old "introduced_phone" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldIntroducedPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroducedPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroducedPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroducedPhone: %w", err)
	}
	return oldValue.IntroducedPhone, nil
}

// ResetIntroducedPhone resets all changes to the "introduced_phone" field.
func (m *ResumeMutation) ResetIntroducedPhone() {
	m.introduced_phone = nil
}

// SetPosition sets the "position" field.
func (m *ResumeMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *ResumeMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *ResumeMutation) ResetPosition() {
	m.position = nil
}

// SetFile sets the "file" field.
func (m *ResumeMutation) SetFile(s string) {
	m.file = &s
}

// File returns the value of the "file" field in the mutation.
func (m *ResumeMutation) File() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFile returns the old "file" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFile: %w", err)
	}
	return oldValue.File, nil
}

// ResetFile resets all changes to the "file" field.
func (m *ResumeMutation) ResetFile() {
	m.file = nil
}

// SetStatus sets the "status" field.
func (m *ResumeMutation) SetStatus(r resume.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ResumeMutation) Status() (r resume.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldStatus(ctx context.Context) (v resume.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResumeMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *ResumeMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ResumeMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ResumeMutation) ResetUserID() {
	m.user = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ResumeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[resume.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ResumeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ResumeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ResumeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ResumeMutation builder.
func (m *ResumeMutation) Where(ps ...predicate.Resume) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resume, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resume).
func (m *ResumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.introduced_name != nil {
		fields = append(fields, resume.FieldIntroducedName)
	}
	if m.introduced_phone != nil {
		fields = append(fields, resume.FieldIntroducedPhone)
	}
	if m.position != nil {
		fields = append(fields, resume.FieldPosition)
	}
	if m.file != nil {
		fields = append(fields, resume.FieldFile)
	}
	if m.status != nil {
		fields = append(fields, resume.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, resume.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resume.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, resume.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resume.FieldIntroducedName:
		return m.IntroducedName()
	case resume.FieldIntroducedPhone:
		return m.IntroducedPhone()
	case resume.FieldPosition:
		return m.Position()
	case resume.FieldFile:
		return m.File()
	case resume.FieldStatus:
		return m.Status()
	case resume.FieldCreatedAt:
		return m.CreatedAt()
	case resume.FieldUpdatedAt:
		return m.UpdatedAt()
	case resume.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resume.FieldIntroducedName:
		return m.OldIntroducedName(ctx)
	case resume.FieldIntroducedPhone:
		return m.OldIntroducedPhone(ctx)
	case resume.FieldPosition:
		return m.OldPosition(ctx)
	case resume.FieldFile:
		return m.OldFile(ctx)
	case resume.FieldStatus:
		return m.OldStatus(ctx)
	case resume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resume.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Resume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resume.FieldIntroducedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroducedName(v)
		return nil
	case resume.FieldIntroducedPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroducedPhone(v)
		return nil
	case resume.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case resume.FieldFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFile(v)
		return nil
	case resume.FieldStatus:
		v, ok := value.(resume.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resume.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeMutation) ResetField(name string) error {
	switch name {
	case resume.FieldIntroducedName:
		m.ResetIntroducedName()
		return nil
	case resume.FieldIntroducedPhone:
		m.ResetIntroducedPhone()
		return nil
	case resume.FieldPosition:
		m.ResetPosition()
		return nil
	case resume.FieldFile:
		m.ResetFile()
		return nil
	case resume.FieldStatus:
		m.ResetStatus()
		return nil
	case resume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resume.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, resume.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resume.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, resume.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeMutation) EdgeCleared(name string) bool {
	switch name {
	case resume.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeMutation) ClearEdge(name string) error {
	switch name {
	case resume.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Resume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeMutation) ResetEdge(name string) error {
	switch name {
	case resume.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Resume edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	email                  *string
	phone                  *string
	first_name             *string
	last_name              *string
	full_name              *string
	role                   *user.Role
	avatar                 *string
	password               *string
	personnel_number       *string
	national_code          *string
	birthdate              *time.Time
	cooperation_start_date *time.Time
	clearedFields          map[string]struct{}
	otps                   map[int]struct{}
	removedotps            map[int]struct{}
	clearedotps            bool
	resumes                map[int]struct{}
	removedresumes         map[int]struct{}
	clearedresumes         bool
	requests               map[int]struct{}
	removedrequests        map[int]struct{}
	clearedrequests        bool
	department             *int
	cleareddepartment      bool
	digikala_codes         map[int]struct{}
	removeddigikala_codes  map[int]struct{}
	cleareddigikala_codes  bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetPersonnelNumber sets the "personnel_number" field.
func (m *UserMutation) SetPersonnelNumber(s string) {
	m.personnel_number = &s
}

// PersonnelNumber returns the value of the "personnel_number" field in the mutation.
func (m *UserMutation) PersonnelNumber() (r string, exists bool) {
	v := m.personnel_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonnelNumber returns the old "personnel_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPersonnelNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonnelNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonnelNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonnelNumber: %w", err)
	}
	return oldValue.PersonnelNumber, nil
}

// ResetPersonnelNumber resets all changes to the "personnel_number" field.
func (m *UserMutation) ResetPersonnelNumber() {
	m.personnel_number = nil
}

// SetNationalCode sets the "national_code" field.
func (m *UserMutation) SetNationalCode(s string) {
	m.national_code = &s
}

// NationalCode returns the value of the "national_code" field in the mutation.
func (m *UserMutation) NationalCode() (r string, exists bool) {
	v := m.national_code
	if v == nil {
		return
	}
	return *v, true
}

// OldNationalCode returns the old "national_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNationalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNationalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNationalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNationalCode: %w", err)
	}
	return oldValue.NationalCode, nil
}

// ResetNationalCode resets all changes to the "national_code" field.
func (m *UserMutation) ResetNationalCode() {
	m.national_code = nil
}

// SetBirthdate sets the "birthdate" field.
func (m *UserMutation) SetBirthdate(t time.Time) {
	m.birthdate = &t
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *UserMutation) Birthdate() (r time.Time, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *UserMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[user.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *UserMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *UserMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, user.FieldBirthdate)
}

// SetCooperationStartDate sets the "cooperation_start_date" field.
func (m *UserMutation) SetCooperationStartDate(t time.Time) {
	m.cooperation_start_date = &t
}

// CooperationStartDate returns the value of the "cooperation_start_date" field in the mutation.
func (m *UserMutation) CooperationStartDate() (r time.Time, exists bool) {
	v := m.cooperation_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCooperationStartDate returns the old "cooperation_start_date" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCooperationStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooperationStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooperationStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooperationStartDate: %w", err)
	}
	return oldValue.CooperationStartDate, nil
}

// ClearCooperationStartDate clears the value of the "cooperation_start_date" field.
func (m *UserMutation) ClearCooperationStartDate() {
	m.cooperation_start_date = nil
	m.clearedFields[user.FieldCooperationStartDate] = struct{}{}
}

// CooperationStartDateCleared returns if the "cooperation_start_date" field was cleared in this mutation.
func (m *UserMutation) CooperationStartDateCleared() bool {
	_, ok := m.clearedFields[user.FieldCooperationStartDate]
	return ok
}

// ResetCooperationStartDate resets all changes to the "cooperation_start_date" field.
func (m *UserMutation) ResetCooperationStartDate() {
	m.cooperation_start_date = nil
	delete(m.clearedFields, user.FieldCooperationStartDate)
}

// AddOtpIDs adds the "otps" edge to the OTP entity by ids.
func (m *UserMutation) AddOtpIDs(ids ...int) {
	if m.otps == nil {
		m.otps = make(map[int]struct{})
	}
	for i := range ids {
		m.otps[ids[i]] = struct{}{}
	}
}

// ClearOtps clears the "otps" edge to the OTP entity.
func (m *UserMutation) ClearOtps() {
	m.clearedotps = true
}

// OtpsCleared reports if the "otps" edge to the OTP entity was cleared.
func (m *UserMutation) OtpsCleared() bool {
	return m.clearedotps
}

// RemoveOtpIDs removes the "otps" edge to the OTP entity by IDs.
func (m *UserMutation) RemoveOtpIDs(ids ...int) {
	if m.removedotps == nil {
		m.removedotps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.otps, ids[i])
		m.removedotps[ids[i]] = struct{}{}
	}
}

// RemovedOtps returns the removed IDs of the "otps" edge to the OTP entity.
func (m *UserMutation) RemovedOtpsIDs() (ids []int) {
	for id := range m.removedotps {
		ids = append(ids, id)
	}
	return
}

// OtpsIDs returns the "otps" edge IDs in the mutation.
func (m *UserMutation) OtpsIDs() (ids []int) {
	for id := range m.otps {
		ids = append(ids, id)
	}
	return
}

// ResetOtps resets all changes to the "otps" edge.
func (m *UserMutation) ResetOtps() {
	m.otps = nil
	m.clearedotps = false
	m.removedotps = nil
}

// AddResumeIDs adds the "resumes" edge to the Resume entity by ids.
func (m *UserMutation) AddResumeIDs(ids ...int) {
	if m.resumes == nil {
		m.resumes = make(map[int]struct{})
	}
	for i := range ids {
		m.resumes[ids[i]] = struct{}{}
	}
}

// ClearResumes clears the "resumes" edge to the Resume entity.
func (m *UserMutation) ClearResumes() {
	m.clearedresumes = true
}

// ResumesCleared reports if the "resumes" edge to the Resume entity was cleared.
func (m *UserMutation) ResumesCleared() bool {
	return m.clearedresumes
}

// RemoveResumeIDs removes the "resumes" edge to the Resume entity by IDs.
func (m *UserMutation) RemoveResumeIDs(ids ...int) {
	if m.removedresumes == nil {
		m.removedresumes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resumes, ids[i])
		m.removedresumes[ids[i]] = struct{}{}
	}
}

// RemovedResumes returns the removed IDs of the "resumes" edge to the Resume entity.
func (m *UserMutation) RemovedResumesIDs() (ids []int) {
	for id := range m.removedresumes {
		ids = append(ids, id)
	}
	return
}

// ResumesIDs returns the "resumes" edge IDs in the mutation.
func (m *UserMutation) ResumesIDs() (ids []int) {
	for id := range m.resumes {
		ids = append(ids, id)
	}
	return
}

// ResetResumes resets all changes to the "resumes" edge.
func (m *UserMutation) ResetResumes() {
	m.resumes = nil
	m.clearedresumes = false
	m.removedresumes = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *UserMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *UserMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *UserMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *UserMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *UserMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *UserMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *UserMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// SetDepartmentID sets the "department" edge to the Department entity by id.
func (m *UserMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *UserMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *UserMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the "department" edge ID in the mutation.
func (m *UserMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddDigikalaCodeIDs adds the "digikala_codes" edge to the DigikalaCode entity by ids.
func (m *UserMutation) AddDigikalaCodeIDs(ids ...int) {
	if m.digikala_codes == nil {
		m.digikala_codes = make(map[int]struct{})
	}
	for i := range ids {
		m.digikala_codes[ids[i]] = struct{}{}
	}
}

// ClearDigikalaCodes clears the "digikala_codes" edge to the DigikalaCode entity.
func (m *UserMutation) ClearDigikalaCodes() {
	m.cleareddigikala_codes = true
}

// DigikalaCodesCleared reports if the "digikala_codes" edge to the DigikalaCode entity was cleared.
func (m *UserMutation) DigikalaCodesCleared() bool {
	return m.cleareddigikala_codes
}

// RemoveDigikalaCodeIDs removes the "digikala_codes" edge to the DigikalaCode entity by IDs.
func (m *UserMutation) RemoveDigikalaCodeIDs(ids ...int) {
	if m.removeddigikala_codes == nil {
		m.removeddigikala_codes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.digikala_codes, ids[i])
		m.removeddigikala_codes[ids[i]] = struct{}{}
	}
}

// RemovedDigikalaCodes returns the removed IDs of the "digikala_codes" edge to the DigikalaCode entity.
func (m *UserMutation) RemovedDigikalaCodesIDs() (ids []int) {
	for id := range m.removeddigikala_codes {
		ids = append(ids, id)
	}
	return
}

// DigikalaCodesIDs returns the "digikala_codes" edge IDs in the mutation.
func (m *UserMutation) DigikalaCodesIDs() (ids []int) {
	for id := range m.digikala_codes {
		ids = append(ids, id)
	}
	return
}

// ResetDigikalaCodes resets all changes to the "digikala_codes" edge.
func (m *UserMutation) ResetDigikalaCodes() {
	m.digikala_codes = nil
	m.cleareddigikala_codes = false
	m.removeddigikala_codes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.personnel_number != nil {
		fields = append(fields, user.FieldPersonnelNumber)
	}
	if m.national_code != nil {
		fields = append(fields, user.FieldNationalCode)
	}
	if m.birthdate != nil {
		fields = append(fields, user.FieldBirthdate)
	}
	if m.cooperation_start_date != nil {
		fields = append(fields, user.FieldCooperationStartDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldRole:
		return m.Role()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPersonnelNumber:
		return m.PersonnelNumber()
	case user.FieldNationalCode:
		return m.NationalCode()
	case user.FieldBirthdate:
		return m.Birthdate()
	case user.FieldCooperationStartDate:
		return m.CooperationStartDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPersonnelNumber:
		return m.OldPersonnelNumber(ctx)
	case user.FieldNationalCode:
		return m.OldNationalCode(ctx)
	case user.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case user.FieldCooperationStartDate:
		return m.OldCooperationStartDate(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPersonnelNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonnelNumber(v)
		return nil
	case user.FieldNationalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNationalCode(v)
		return nil
	case user.FieldBirthdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case user.FieldCooperationStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooperationStartDate(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldBirthdate) {
		fields = append(fields, user.FieldBirthdate)
	}
	if m.FieldCleared(user.FieldCooperationStartDate) {
		fields = append(fields, user.FieldCooperationStartDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case user.FieldCooperationStartDate:
		m.ClearCooperationStartDate()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPersonnelNumber:
		m.ResetPersonnelNumber()
		return nil
	case user.FieldNationalCode:
		m.ResetNationalCode()
		return nil
	case user.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case user.FieldCooperationStartDate:
		m.ResetCooperationStartDate()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.otps != nil {
		edges = append(edges, user.EdgeOtps)
	}
	if m.resumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	if m.requests != nil {
		edges = append(edges, user.EdgeRequests)
	}
	if m.department != nil {
		edges = append(edges, user.EdgeDepartment)
	}
	if m.digikala_codes != nil {
		edges = append(edges, user.EdgeDigikalaCodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOtps:
		ids := make([]ent.Value, 0, len(m.otps))
		for id := range m.otps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.resumes))
		for id := range m.resumes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeDigikalaCodes:
		ids := make([]ent.Value, 0, len(m.digikala_codes))
		for id := range m.digikala_codes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedotps != nil {
		edges = append(edges, user.EdgeOtps)
	}
	if m.removedresumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	if m.removedrequests != nil {
		edges = append(edges, user.EdgeRequests)
	}
	if m.removeddigikala_codes != nil {
		edges = append(edges, user.EdgeDigikalaCodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOtps:
		ids := make([]ent.Value, 0, len(m.removedotps))
		for id := range m.removedotps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.removedresumes))
		for id := range m.removedresumes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDigikalaCodes:
		ids := make([]ent.Value, 0, len(m.removeddigikala_codes))
		for id := range m.removeddigikala_codes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedotps {
		edges = append(edges, user.EdgeOtps)
	}
	if m.clearedresumes {
		edges = append(edges, user.EdgeResumes)
	}
	if m.clearedrequests {
		edges = append(edges, user.EdgeRequests)
	}
	if m.cleareddepartment {
		edges = append(edges, user.EdgeDepartment)
	}
	if m.cleareddigikala_codes {
		edges = append(edges, user.EdgeDigikalaCodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOtps:
		return m.clearedotps
	case user.EdgeResumes:
		return m.clearedresumes
	case user.EdgeRequests:
		return m.clearedrequests
	case user.EdgeDepartment:
		return m.cleareddepartment
	case user.EdgeDigikalaCodes:
		return m.cleareddigikala_codes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOtps:
		m.ResetOtps()
		return nil
	case user.EdgeResumes:
		m.ResetResumes()
		return nil
	case user.EdgeRequests:
		m.ResetRequests()
		return nil
	case user.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case user.EdgeDigikalaCodes:
		m.ResetDigikalaCodes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
